<html>
  <head>
    <script type="text/javascript">
      var numjs = {};

      numjs.WebGl = {};

      numjs.WebGl.formatError = function(log, src) {
        var match = log.match(/ERROR: [0-9]*:([0-9]*): (.*)/);
        var line = parseInt(match[1]);
        var msg = match[2];

        var lines = src.split('\n');
        return [].concat(
          lines.slice(0, line),
          ['/********************************',
           ' * ',
           ' * ' + msg,
           ' * ',
           ' ********************************/',
           ''],
          lines.slice(line)
        ).join('\n');
      };

      numjs.WebGl.createShaderProgramFromSource = function(gl, vertexSrc, fragmentSrc, attr0) {
        // create vertex shader
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexSrc);
        gl.compileShader(vertexShader);

        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
          var err = numjs.WebGl.formatError(gl.getShaderInfoLog(vertexShader), vertexSrc);
          console.error(err);
          throw err;
        }

        // create fragment shader
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentSrc);
        gl.compileShader(fragmentShader);

        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
          var err = numjs.WebGl.formatError(gl.getShaderInfoLog(fragmentShader), fragmentSrc);
          console.error(err);
          throw err;
        }

        // link shaders to create our program
        var program = gl.createProgram();
        program.gl = gl;
        program.vertexSrc = vertexSrc;
        program.fragmentSrc = fragmentSrc;
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);

        if (attr0 != undefined) {
          gl.bindAttribLocation(program, 0, attr0);
        }

        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          var err = gl.getProgramInfoLog(program);
          console.error(err);
          throw err;
        }

        gl.useProgram(program);

        // Collect attribute locations to make binding easier in the code using this program
        program.attributes = {};
        program.buffers = {};
        for (var i = 0; i < gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES); i++) {
          var name = gl.getActiveAttrib(program, i).name;
          program.attributes[name] = gl.getAttribLocation(program, name);
          program.buffers[name] = gl.createBuffer();
        }

        program.uniforms = {};
        for (var i = 0; i < gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS); i++) {
          var name = gl.getActiveUniform(program, i).name;
          program.uniforms[name] = gl.getUniformLocation(program, name);
        }

        program.boundAttributes = [];

        program.loadArray = function(name, arraydata, size, type, stride, offset) {
          var gl = program.gl;
          if (program.attributes[name] == undefined) {
            console.warn(["Attempted to set an non-existent attribute " + name + ".", program]);
          } else if (arraydata == null) {
            gl.disableVertexAttribArray(program.attributes[name]);
          } else {
            program.boundAttributes.push(program.attributes[name]);

            gl.bindBuffer(gl.ARRAY_BUFFER, program.buffers[name]);
            gl.bufferData(gl.ARRAY_BUFFER, arraydata, gl.STATIC_DRAW);

            gl.enableVertexAttribArray(program.attributes[name]);
            gl.vertexAttribPointer(program.attributes[name], size, type, false, stride || 0, offset || 0);
          }
        };

        program.disableArrays = function() {
          program.boundAttributes.map(function (idx) {
            program.gl.disableVertexAttribArray(idx);
          });
          program.boundAttributes = [];
        };


        return program;
      };


      numjs.isLittleEndian = function() {
        var arrayBuffer = new ArrayBuffer(2);
        var uint8Array = new Uint8Array(arrayBuffer);
        var uint16array = new Uint16Array(arrayBuffer);
        uint8Array[0] = 0xAA;
        uint8Array[1] = 0xBB;
        if (uint16array[0] === 0xBBAA) {
          return true;
        } else if (uint16array[0] === 0xAABB) {
          return false;
        } else {
          throw new Error("Broken typed array implementation detected");
        }
      };


      numjs.shaders = {};

      numjs.shaders.float2color = function() {
        var handleLittleEndian = '';
        if (numjs.isLittleEndian()) {
          handleLittleEndian = `
            res = vec4(res[3], res[2], res[1], res[0]);
          `;
        }

        return `
          bool isnan(float val) {
            return (val < 0.0 || 0.0 < val || val == 0.0) ? false : true;
          }

          bool isinf(float val) {
            return (val != 0.0 && val * 2.0 == val) ? true : false;
          }

          vec4 float2color(float value) {
            float sign = 0.0;
            float exp = 0.0;
            vec3 frac = vec3(0.0, 0.0, 0.0);

            if (value < 0.0) {
              sign = 1.0;
              value = -value;
            }

            if (isnan(value)) {
              exp = 255.0;
              frac = vec3(64.0, 0.0, 0.0);
            } else if (isinf(value)) {
              exp = 255.0;
              frac = vec3(0.0, 0.0, 0.0);
            } else if (value == 0.0) {
              exp = 0.0;
              frac = vec3(0.0, 0.0, 0.0);
            } else {
              exp = floor(log2(value)) + 127.0;

              // while (value < exp2(23.0)) {
              for (int i = 0; i < 24; i++) {
                if (value >= exp2(23.0)) break;
                value = value * 2.0;
              }
              value = value - exp2(23.0);

              frac[0] = floor(value / exp2(16.0));
              value = value - frac[0] * exp2(16.0);
              frac[1] = floor(value / exp2(8.0));
              value = value - frac[1] * exp2(8.0);
              frac[2] = value;
            }

            vec4 res = vec4(
              sign * 128.0 + floor(exp / 2.0),
              mod(exp, 2.0) * 128.0 + frac[0],
              frac[1],
              frac[2]
            ) / vec4(255.0, 255.0, 255.0, 255.0);

            ${handleLittleEndian}

            return res;
          }
        `;
      };

      numjs.shaders.vertex = function(expr, interpolate) {
        var header = 'varying float res;';
        var res = `${expr}`
        if (!interpolate) {
          header = numjs.shaders.float2color() + 'varying vec4 res;';
          res = `float2color(${expr})`
        }

        return `
          ${header}

          attribute float x;
          attribute float y;
          attribute float a;
          uniform float width;
          uniform float height;

          void main () {
            gl_Position = vec4(
              2. * (x + .5) / width - 1.,
              2. * (y + .5) / height - 1.,
              -1, 1.);
            gl_PointSize=1.0;
            res = ${res};
          }
        `;
      };

      numjs.shaders.fragment = function(interpolate) {
        var header = 'varying vec4 res;';
        var expr = 'res';

        if (interpolate) {
          var header = numjs.shaders.float2color() + 'varying float res;';
          expr = 'float2color(res)';
        }

        return `
          precision mediump float;

          ${header}

          void main() {
            gl_FragColor = ${expr};
          }
        `;
      };


      numjs.Context = function () {
        var self = this;

        self.canvas = document.createElement('canvas');
        self.gl = self.canvas.getContext('experimental-webgl', {preserveDrawingBuffer: true, antialias: false});
        self.gl.clearColor(1.0, 1.0, .0, 1.0);
        self.programs = {};
        self.programs.range = numjs.WebGl.createShaderProgramFromSource(self.gl, numjs.shaders.vertex('a', true), numjs.shaders.fragment(true), "x");
        self.programs.identity = numjs.WebGl.createShaderProgramFromSource(self.gl, numjs.shaders.vertex('a', false), numjs.shaders.fragment(false), "x");
      };
      numjs.Context.prototype.setOutput = function (name, width, height) {
        var self = this;
        var program = self.programs[name];
        self.canvas.width = width;
        self.canvas.height = height;
        self.gl.useProgram(program);
        self.gl.viewport(0, 0, self.canvas.width, self.canvas.height);
        program.gl.uniform1f(program.uniforms.width, self.canvas.width);
        program.gl.uniform1f(program.uniforms.height, self.canvas.height);
        self.gl.clear(self.gl.COLOR_BUFFER_BIT);
        return program;
      };
      numjs.Context.prototype.getOutput = function(x, y, w, h) {
        var self = this;
var width = w || self.canvas.width;
var height = h || self.canvas.height;
        var pixels = new Uint8Array(4 * width * height);
        self.gl.readPixels(x || 0, y || 0, width, height, self.gl.RGBA, self.gl.UNSIGNED_BYTE, pixels);
        return new Float32Array(pixels.buffer);
      }
      numjs.Context.prototype.range = function (length) {
        var self = this;


//        var program = self.setOutput("range", length, 1);
        var program = self.setOutput("range", 20, 20);

        var x = new Float32Array(2);
        var y = new Float32Array(2);
        var a = new Float32Array(2);

        x[0] = 1;
        y[0] = 1;
        a[0] = 0;
        x[1] = 1 + length;
        y[1] = 1;
        a[1] = 1;

        program.loadArray("x", x, 1,  self.gl.FLOAT);
        program.loadArray("y", y, 1,  self.gl.FLOAT);
        program.loadArray("a", a, 1,  self.gl.FLOAT);

        self.gl.drawArrays(self.gl.LINES, 0, 2);

        program.disableArrays(program);

        res = self.getOutput(1, 1, length, 1);
print("XXXX: " +  res[res.length - 1].toString())
        return self.getOutput(1, 1, length, 1);
      }
      numjs.Context.prototype.identity = function (length) {
        var self = this;

        var program = self.setOutput("identity", length, 1);

        var x = new Float32Array(length);
        var y = new Float32Array(length);
        var a = new Float32Array(length);

        for (var i = 0; i < length; i++) {
          x[i] = i;
          y[i] = 0;
          a[i] = i * 2 + 1;
        }

        program.loadArray("x", x, 1,  self.gl.FLOAT);
        program.loadArray("y", y, 1,  self.gl.FLOAT);
        program.loadArray("a", a, 1,  self.gl.FLOAT);

        self.gl.drawArrays(self.gl.POINTS, 0, length);

        program.disableArrays();

        return self.getOutput();
      }


      function print(x) {
        var res = document.createElement('div');
        document.body.appendChild(res);
        res.innerHTML = x;
      }

      window.onload = function() {
        var ctx = new numjs.Context();

        document.body.appendChild(ctx.canvas);

        print("range(5) = " + ctx.range(5));
        // print("identity(10) = " + ctx.identity(10));
      }
    </script>

    <style>
     body {
       background: green;
     }
     canvas {
       border: 2px solid red;
     }
    </style>
  </head>
  <body>
  </body>
</html>
